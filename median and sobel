bool median(int rows, int cols){
	
	copy_channels(rows, cols);

	// create kernel
	int kernel_b[3][3];
	int kernel_r[3][3];
	int kernel_g[3][3];

	// create array for sorting
	int sort_array_b[9];
	int sort_array_r[9];
	int sort_array_g[9];

	// begin looping over the image excluding edges
	for(int i = 1; i < (rows - 1); i++){
		for(int j = 1; j < (cols - 1); j++){

			// fill kernels
			kernel_b[0][0] = blue[i-1][j-1];
			kernel_b[0][1] = blue[i][j-1];
			kernel_b[0][2] = blue[i+1][j-1];
			kernel_b[1][0] = blue[i-1][j];
			kernel_b[1][1] = blue[i][j];
			kernel_b[1][2] = blue[i+1][j];
			kernel_b[2][0] = blue[i-1][j+1];
			kernel_b[2][1] = blue[i][j+1];
			kernel_b[2][2] = blue[i+1][j+1];

			kernel_r[0][0] = red[i-1][j-1];
			kernel_r[0][1] = red[i][j-1];
			kernel_r[0][2] = red[i+1][j-1];
			kernel_r[1][0] = red[i-1][j];
			kernel_r[1][1] = red[i][j];
			kernel_r[1][2] = red[i+1][j];
			kernel_r[2][0] = red[i-1][j+1];
			kernel_r[2][1] = red[i][j+1];
			kernel_r[2][2] = red[i+1][j+1];

			kernel_g[0][0] = green[i-1][j-1];
			kernel_g[0][1] = green[i][j-1];
			kernel_g[0][2] = green[i+1][j-1];
			kernel_g[1][0] = green[i-1][j];
			kernel_g[1][1] = green[i][j];
			kernel_g[1][2] = green[i+1][j];
			kernel_g[2][0] = green[i-1][j+1];
			kernel_g[2][1] = green[i][j+1];
			kernel_g[2][2] = green[i+1][j+1];

			// fill sorting arrays
			int tmp_b = 0;
			for(int k = 0; k < 3; k++){
				for(int l = 0; l < 3; l++){
					sort_array_b[tmp_b] = kernel_b[k][l];
					tmp_b++;
				}
			}

			int tmp_r = 0;
			for(int k = 0; k < 3; k++){
				for(int l = 0; l < 3; l++){
					sort_array_r[tmp_r] = kernel_r[k][l];
					tmp_r++;
				}
			}

			int tmp_g = 0;
			for(int k = 0; k < 3; k++){
				for(int l = 0; l < 3; l++){
					sort_array_g[tmp_g] = kernel_g[k][l];
					tmp_g++;
				}
			}

			// sort arrays and find median value
			for (int m = 8; m > 0; --m){
				if(sort_array_b[m] > sort_array_b[m+1] {
					int temp = sort_array_b[m];
					sort_array_b[m] = sort_array_b[m+1];
					sort_array_b[m+1] = temp;
				}
			}
			int median_b = sort_array_b[5];

			for (int m = 8; m > 0; --m){
				if(sort_array_r[m] > sort_array_r[m+1] {
					int temp = sort_array_r[m];
					sort_array_r[m] = sort_array_r[m+1];
					sort_array_r[m+1] = temp;
				}
			}
			int median_r = sort_array_r[5];

			for (int m = 8; m > 0; --m){
				if(sort_array_g[m] > sort_array_g[m+1] {
					int temp = sort_array_g[m];
					sort_array_g[m] = sort_array_g[m+1];
					sort_array_g[m+1] = temp;
				}
			}
			int median_g = sort_array_g[5];


			// change source image copy
			if(median_b < 0) {
				median_b = 0;
			}
			if(median_b > 255) {
				median_b = 255;
			}
				
			if(median_r < 0) {
				median_r = 0;
			}
			if(median_r > 255) {
				median_r = 255;
			}
				
			if(median_g < 0) {
				median_g = 0;
			}
			if(median_g > 255) {
				median_g = 255;
			}
				

			blue_channel_copy[i][j] = median_b;
			green_channel_copy[i][j] = median_g;
			red_channel_copy[i][j] = median_r;
		}
	}
	return true;

}

bool sobel(int rows, int cols){
		
		copy_channels(rows,cols);
		

		// create horizontal edge sliding window / mask / kernel and fill it
		int kernel_x[3][3] =
		{
			-1, 0, 1,
			-2, 0, 2,
			-1, 0, 1
		};

		// create vertical edge sliding window / mask / kernel and fill it
		int kernel_y[3][3] =
		{
			-1, -2, -1,
			0, 0, 0,
			1, 2, 1
		};

		// begin looping over the image excluding edges
		for(int i = 1; i < (rows - 1); i++){
			for(int j = 1; j < (cols - 1); j++){

				// pass the first kernel over the blue source
				int x_edge_blue =
				((blue[i-1][j-1] * kernel_x[0][0])) +
				((blue[i-1][j] * kernel_x[0][1])) +
				((blue[i-1][j+1] * kernel_x[0][2])) +
				((blue[i][j-1] * kernel_x[1][0])) +
				((blue[i][j] * kernel_x[1][1])) +
				((blue[i][j+1] * kernel_x[1][2])) +
				((blue[i+1][j-1] * kernel_x[2][0])) +
				((blue[i+1][j] * kernel_x[2][1])) +
				((blue[i+1][j+1] * kernel_x[2][2]));

				// pass the second kernel over the blue source
				int y_edge_blue =
				((blue[i-1][j-1] * kernel_y[0][0])) +
				((blue[i-1][j] * kernel_y[0][1])) +
				((blue[i-1][j+1] * kernel_y[0][2])) +
				((blue[i][j-1] * kernel_y[1][0])) +
				((blue[i][j] * kernel_y[1][1])) +
				((blue[i][j+1] * kernel_y[1][2])) +
				((blue[i+1][j-1] * kernel_y[2][0])) +
				((blue[i+1][j] * kernel_y[2][1])) +
				((blue[i+1][j+1] * kernel_y[2][2]));

				// pass the first kernel over the red source
				int x_edge_red =
				((red[i-1][j-1] * kernel_x[0][0])) +
				((red[i-1][j] * kernel_x[0][1])) +
				((red[i-1][j+1] * kernel_x[0][2])) +
				((red[i][j-1] * kernel_x[1][0])) +
				((red[i][j] * kernel_x[1][1])) +
				((red[i][j+1] * kernel_x[1][2])) +
				((red[i+1][j-1] * kernel_x[2][0])) +
				((red[i+1][j] * kernel_x[2][1])) +
				((red[i+1][j+1] * kernel_x[2][2]));

				// pass the second kernel over the red source
				int y_edge_red =
				((red[i-1][j-1] * kernel_y[0][0])) +
				((red[i-1][j] * kernel_y[0][1])) +
				((red[i-1][j+1] * kernel_y[0][2])) +
				((red[i][j-1] * kernel_y[1][0])) +
				((red[i][j] * kernel_y[1][1])) +
				((red[i][j+1] * kernel_y[1][2])) +
				((red[i+1][j-1] * kernel_y[2][0])) +
				((red[i+1][j] * kernel_y[2][1])) +
				((red[i+1][j+1] * kernel_y[2][2]));

				// pass the first kernel over the green source
				int x_edge_green =
				((green[i-1][j-1] * kernel_x[0][0])) +
				((green[i-1][j] * kernel_x[0][1])) +
				((green[i-1][j+1] * kernel_x[0][2])) +
				((green[i][j-1] * kernel_x[1][0])) +
				((green[i][j] * kernel_x[1][1])) +
				((green[i][j+1] * kernel_x[1][2])) +
				((green[i+1][j-1] * kernel_x[2][0])) +
				((green[i+1][j] * kernel_x[2][1])) +
				((green[i+1][j+1] * kernel_x[2][2]));

				// pass the second kernel over the green source
				int y_edge_green =
				((green[i-1][j-1] * kernel_y[0][0])) +
				((green[i-1][j] * kernel_y[0][1])) +
				((green[i-1][j+1] * kernel_y[0][2])) +
				((green[i][j-1] * kernel_y[1][0])) +
				((green[i][j] * kernel_y[1][1])) +
				((green[i][j+1] * kernel_y[1][2])) +
				((green[i+1][j-1] * kernel_y[2][0])) +
				((green[i+1][j] * kernel_y[2][1])) +
				((green[i+1][j+1] * kernel_y[2][2]));

				// approximate the gradient vector g = sqrt(x^2 + y^2) with g = |x| + |y|
				int gradient_blue = std::abs(x_edge_blue) + std::abs(y_edge_blue);
				int gradient_red = std::abs(x_edge_red) + std::abs(y_edge_red);
				int gradient_green = std::abs(x_edge_green) + std::abs(y_edge_green);

				// change source image copy
				if(gradient_blue < 0) {
					gradient_blue = 0;
				}
				if(gradient_blue > 255) {
					gradient_blue = 255;
				}
				
				if(gradient_green < 0) {
					gradient_green = 0;
				}
				if(gradient_green > 255) {
					gradient_green = 255;
				}
				
				if(gradient_red < 0) {
					gradient_red = 0;
				}
				if(gradient_red > 255) {
					gradient_red = 255;
				}
				

				blue_channel_copy[i][j] = gradient_blue;
				green_channel_copy[i][j] = gradient_green;
				red_channel_copy[i][j] = gradient_red;
			}
		}
	return true;

}
